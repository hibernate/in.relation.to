= "Using ServiceLoader to add custom constraint definitions"
Marko Bekhta
:awestruct-tags: [ "Hibernate Validator", "Discussions" ]
:awestruct-layout: blog-post
---

Have you ever been in a situation, when you would like to get even more from the lib
that you are using all the time? Or when you want to somehow change its behavior ?

Today we'll be talking about Hibernate Validator and how you can provide your own constraint
and/or validator in a fully self-contained manner. Meaning packaging it all into it's own jar file,
in a way that the others can use your lib for their needs.

This functionality is based on Hibernate Validators usage of Java's https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[ServiceLoader]
mechanism that allows to register additional constraint definitions
(https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#_constraint_definitions_via_code_serviceloader_code[see here]).

How does it work? It's really simple, all you need is to provide your own constraint definitions (ServiceProviders)
and register them in a specific file in `META-INF/services` directory of your jar. But more on that later.

== Use standard annotations for nonstandard classes

First let's consider a case when you would want one (or few) of standard bean validation
annotations (or not as standard Hibernate Validator ones) to support some other type, besides
the ones that are already supported.

=== ThreeTen Extra types validation

So what can be a real life scenario for building your own lib with constraints and sharing it? Well let's say that
you are building some library with data classes that user might want to validate. As it would be almost
impossible to keep track of all such libraries and write/maintain all those constraints for them - Hibernate
Validator provides authors of such libs a possibility to write and share their own validation extensions.
Which can be picked up by HV and used to validate your data classes.

In this section we will look at http://www.threeten.org/threeten-extra/[ThreeTen Extra types] - a great lib
that provides additional date-time classes to complement those already present in Java.

As you may already know, Bean Validation (and Hibernate Validator in particular) provides support for the range of
the https://jcp.org/en/jsr/detail?id=310[JSR 310] date types (javax.time API), by the use of
`@Past`/`@Future` annotations. So we would want to use these annotations on ThreeTen Extra types as well.

To still keep this example simple we will provide validators only for http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/DayOfMonth.html[`DayOfMonth`]
and http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Quarter.html[`Quarter`].

We will create a maven project with two modules - one will contain validators, another will contain tests.
You can look at complete code at http://some-valid-github-link-to-hibernate-demo-repo-will-be-here[github].
Here's a list of dependencies needed for our validators:

[source,xml]
._pom.xml_
<dependencies>
	<dependency>
		<groupId>javax.validation</groupId>
		<artifactId>validation-api</artifactId>
		<version>2.0.0-SNAPSHOT</version>
	</dependency>
	<!--HV dependencies-->
	<dependency>
		<groupId>org.hibernate</groupId>
		<artifactId>hibernate-validator</artifactId>
		<version>6.0.0-SNAPSHOT</version>
	</dependency>
	<dependency>
		<groupId>org.glassfish</groupId>
		<artifactId>javax.el</artifactId>
		<version>3.0.1-b08</version>
	</dependency>
	<!--Date-time model dependencies-->
	<dependency>
		<groupId>org.threeten</groupId>
		<artifactId>threeten-extra</artifactId>
		<version>1.0</version>
	</dependency>
	<!--Test dependencies-->
	<dependency>
		<groupId>org.testng</groupId>
		<artifactId>testng</artifactId>
		<version>6.8</version>
	</dependency>
</dependencies>

Validator module does not require whole Hibernate Validator but just validation api (`validation-api`) to get
 `@Past` \ `@Future` annotations and `ConstraintValidator` interface, which should be implemented by your
validator. As for the tests we will need Hibernate validator as a reference implementation of Bean Validation.

Where should we start? Well without an implementation of a validator we will not get far. So let's start with it.
A possible FutureDayOfMonthValidator can look like this:

```java
public class FutureDayOfMonthValidator implements ConstraintValidator<Future, DayOfMonth> {

	public boolean isValid(DayOfMonth value, ConstraintValidatorContext context) {
		return DayOfMonth.now().compareTo( value ) < 0;
	}
}
```

In a same manner we can implement others - `FutureQuarterValidator`, `PastDayOfMonthValidator`, `PastQuarterValidator`.

Next step is to provide a list of implemented validators (Service Providers) in `META-INF/services/javax.validation.ConstraintValidator`
folder.

	#providing a list of new validators for @Past and @Future
    org.hibernate.validator.example.PastQuarterValidator
    org.hibernate.validator.example.FutureQuarterValidator
    org.hibernate.validator.example.FutureDayOfMonthValidator
    org.hibernate.validator.example.PastDayOfMonthValidator

After this we can package it all in a jar file and we are ready to use our validators, and share them with
the world!

In the end our project structure should look similar to this:

image::external_validators_project_structure.png["project structure, align="center", width="400"]

A simple test to check that we are right:

```java
public class DayOfMonthTest extends AbstractValidationTest {

	@Test
	public void testPast() {
		Assert.assertTrue( validator.validate( new PastEvent( DayOfMonth.of( 1 ) ) ).isEmpty() );
		Assert.assertEquals( validator.validate( new PastEvent( DayOfMonth.of( 31 ) ) ).size(), 1 );
	}

	@Test
	public void testFuture() {
		Assert.assertTrue( validator.validate( new FutureEvent( DayOfMonth.of( 31 ) ) ).isEmpty() );
		Assert.assertEquals( validator.validate( new FutureEvent( DayOfMonth.of( 1 ) ) ).size(), 1 );
	}

	public static class PastEvent {

		@Past
		private DayOfMonth dayOfMonth;

		public PastEvent(DayOfMonth dayOfMonth) {
			this.dayOfMonth = dayOfMonth;
		}
	}

	public static class FutureEvent {

		@Future
		private DayOfMonth dayOfMonth;

		public FutureEvent(DayOfMonth dayOfMonth) {
			this.dayOfMonth = dayOfMonth;
		}
	}

}
```

== Using custom annotations and validators

So until now we were looking at possibility to provide additional validators for existing
constraint annotations. But it is possible to do the same with your own custom annotations
as well.

=== Time, it needs time ...

If we were talking about date-time related validation let's stay on the same topic for this example as well.
Not all https://jcp.org/en/jsr/detail?id=310[JSR 310] types are covered at this moment and one of the types,
missing validation is https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html[`Duration`]. This
type is not describing a point in time so regular date/time annotations (`@Future` \ `@Past`) do not make sense
for it. So one of the possible solutions for `Duration` validation problem is to introduce a new annotation
specific to this type. Let's call it '@MinDuration'. And it will mean that the value annotated with it cannot
represent a smaller duration period than the one represented by the annotation parameters.

Also let's make another assumption for this example. As you are trying to be a good developer, and provide end
users of your lib only with the relevant classes and hide implementation details from them, you don't want to
expose your validator implementation by mentioning it as a `validatedBy` parameter of `@Constraint(validatedBy = { })`
annotation (as well as making an import of it from your `*.impl` or `*.internal` package where all the magic things
are happening). It's a good practice to keep your public API clean and hide any implementation details. There's
http://http://in.relation.to/2017/01/31/preventing-leaky-apis-with-jqassistant/[this] great post about a tool that
can help you analyze your code and make sure that it is not leaking anything that is implementation only and
not for the public.

Let's get back to validating our beans - as that's why we all gathered here, right ? :)

Possible version of our new constraint annotation '@MinDuration' might look like this:

```java
@Documented
@Constraint(validatedBy = { })
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@ReportAsSingleViolation
public @interface DurationMin {

	String message() default "{org.hibernate.validator.constraints.time.DurationMin.message}";

	Class<?>[] groups() default { };

	Class<? extends Payload>[] payload() default { };

	long value() default 0;

	ChronoUnit units() default ChronoUnit.NANOS;

	/**
	 * Defines several {@code @DurationMin} annotations on the same element.
	 */
	@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
	@Retention(RUNTIME)
	@Documented
	@interface List {

		DurationMin[] value();
	}
}
```

And we would place it in a public package of our lib - `org.hibernate.validator.constraints.time`. Now that we
have an annotation we would want to start writing a validator for `Duration` and this newly created annotation.
To do that you need to implement `ConstraintValidator<DurationMin, Duration>` interface, which contains two methods

* `initialize` - initializes validator based on annotation parameters.
* `isValid` - performs actual validation

A possible implementation can be next:

```java
public class DurationMinValidator implements ConstraintValidator<DurationMin, Duration> {

	private Duration duration;

	@Override
	public void initialize(DurationMin constraintAnnotation) {
		this.duration = Duration.of( constraintAnnotation.value(), constraintAnnotation.units() );
	}

	@Override
	public boolean isValid(Duration value, ConstraintValidatorContext context) {
		// null values are valid
		if ( value == null ) {
			return true;
		}
		return duration.compareTo( value ) < 1;
	}
}
```

As was mentioned earlier - you want to hide this implementation from API users by putting it somewhere in internal
packages, in our case it will be - `org.hibernate.validator.internal.constraintvalidators.hv.time`.

As we are creating a new constraint annotation we should also provide a default message for it as well. This can be
done by placing `ContributorValidationMessages.properties` property file on a classpath. This property file should
contain a key/message pair, where key is the one used in annotation declaration (in our case it's
`org.hibernate.validator.constraints.time.DurationMin.message`). And message is the one you would like to show
when validation fails. A possible content of this property file in our case can be:

	org.hibernate.validator.constraints.time.DurationMin.message = must be greater than or equal to {value} {units}

If you leave everything else as is your constraint annotation will live its own life without knowing about a presence
of validator. Hibernate Validator will not know about your `DurationMinValidator` as well. So to make sure that
Hibernate Validator find your `DurationMinValidator` you need to create `META-INF/services/javax.validation.ConstraintValidator`
file and put a fully qualified name of validator you want to be exposed to Hibernate Validator:

	#providing a list of validators for new @DurationMin annotation
    org.hibernate.validator.internal.constraintvalidators.hv.time.DurationMinValidator

To make sure that it all worked out let's run a test:

```java
Some cool test case will appear here later ;)
```

All code can for this example can be found at http://some-valid-github-link-to-hibernate-demo-repo-will-be-here[GitHub]

== Messages

This mechanism can also be used in structuring your custom constraint messages. Instead of having them all
together you can group them by modules and they will be picked up and used by Hibernate Validator. To achive this
just make sure that each module that you'd like to have custom messages have `ContributorValidationMessages.properties`
property file which contains key/message pairs for those constraints that are needed in that particular module.

== Conclusions

So as you can see building and sharing your own validators is a really simple process. And it can be done in a few
simple steps:

- create validator by implementing `ConstraintValidator` interface
- reference that validators fully qualified name in `META-INF/services/javax.validation.ConstraintValidator` file
- (optional) add custom/default messages by adding `ContributorValidationMessages.properties` file
- package it all as a jar
- you are ready to use and share your validators!
