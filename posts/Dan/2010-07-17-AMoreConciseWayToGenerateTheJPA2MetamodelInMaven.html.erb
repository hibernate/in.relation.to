---
title: "A more concise way to generate the JPA 2 metamodel in Maven"
author: "Dan Allen"
blogger_name: "Dan"
creation_date: "17-07-2010"
tags: [Hibernate,JPA,Maven]

absolute_url: http://in.relation.to/2010/07/17/AMoreConciseWayToGenerateTheJPA2MetamodelInMaven
lace: http://in.relation.to/16308.lace
slug: AMoreConciseWayToGenerateTheJPA2MetamodelInMaven

layout: blog-post
---
<div id="documentDisplay" class="documentDisplay">


<p class="wikiPara">
The <a href="http://docs.jboss.org/hibernate/jpamodelgen/1.0/reference/en-US/html_single/#whatisit" target="" class="regularLink">JPA 2 metamodel</a> is the cornerstone of type-safe criteria queries in JPA 2. The generated classes allow you to refer to entity properties using static field references, instead of strings. (A metamodel class is the fully-qualified class name of the entity class it matches followed by an underscore (_)).
</p>

<p class="wikiPara">
It sounds promising, but many people using Maven are getting tripped up trying to get the metamodel generated and compiled. The <a href="http://docs.jboss.org/hibernate/jpamodelgen/1.0/reference/en-US/html_single" target="" class="regularLink">Hibernate JPA 2 Metamodel Generator guide offers</a> a couple of solutions. I've figured out another, which seems more elegant.
</p>

<p class="wikiPara">
Just to refresh your memory of the problem:
</p>

<ol class="wikiOrderedList">
<li class="wikiOrderedListItem"> Maven compiles the classes during the compile phase</li>
<li class="wikiOrderedListItem"> The Java 6 compiler allows annotation processors to hook into it</li>
<li class="wikiOrderedListItem"> Annotation processors are permitted to generate Java source files (which is the case with the JPA 2 metamodel)</li>
<li class="wikiOrderedListItem"> Maven does not execute a secondary compile step to compile Java source files generated by the annotation processor</li>
</ol>

<p class="wikiPara">
I figured out that it's possible to use the Maven compiler plugin to run only the annotation processors during the generate-sources phase! This effectively becomes a code generation step. Then comes the only downside. If you can believe it, Maven does not have a built-in way to compile generated sources. So we have to add one more plugin (<a href="http://mojo.codehaus.org/build-helper-maven-plugin/" target="" class="regularLink">build-helper-maven-plugin</a>) that simply adds an additional source folder (I really can't believe the compiler plugin doesn't offer this feature). During the compile phase, we can disable the annotation processors to speed up compilation and avoid generating the metamodel a second time.
</p>

<p class="wikiPara">
Here's the configuration for your copy-paste pleasure. Add it to the <tt>&lt;plugins&gt;</tt> section of your POM.
</p>

<pre class="wikiPreformatted">&lt;!-- Compiler plugin enforces Java 1.6 compatibility and controls execution of annotation processors --&gt;
&lt;plugin&gt;
   &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
   &lt;version&gt;2.3.1&lt;/version&gt;
   &lt;configuration&gt;
      &lt;source&gt;1.6&lt;/source&gt;
      &lt;target&gt;1.6&lt;/target&gt;
      &lt;compilerArgument&gt;-proc:none&lt;/compilerArgument&gt;
   &lt;/configuration&gt;
   &lt;executions&gt;
      &lt;execution&gt;
         &lt;id&gt;run-annotation-processors-only&lt;/id&gt;
         &lt;phase&gt;generate-sources&lt;/phase&gt;
         &lt;configuration&gt;
            &lt;compilerArgument&gt;-proc:only&lt;/compilerArgument&gt;
            &lt;!-- If your app has multiple packages, use this include filter to
                 execute the processor only on the package containing your entities --&gt;
            &lt;!--
            &lt;includes&gt;
               &lt;include&gt;**/model/*.java&lt;/include&gt;
            &lt;/includes&gt;
            --&gt;
         &lt;/configuration&gt;
         &lt;goals&gt;
            &lt;goal&gt;compile&lt;/goal&gt;
         &lt;/goals&gt;
      &lt;/execution&gt;
   &lt;/executions&gt;  
&lt;/plugin&gt;         
&lt;!-- Build helper plugin adds the sources generated by the JPA 2 annotation processor to the compile path --&gt;
&lt;plugin&gt;
   &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
   &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;
   &lt;version&gt;1.5&lt;/version&gt;
   &lt;executions&gt;      
      &lt;execution&gt; 
         &lt;phase&gt;process-sources&lt;/phase&gt;
         &lt;configuration&gt;
            &lt;sources&gt;
               &lt;source&gt;${project.build.directory}/generated-sources/annotations&lt;/source&gt;
            &lt;/sources&gt;
         &lt;/configuration&gt;
         &lt;goals&gt;
            &lt;goal&gt;add-source&lt;/goal&gt;
         &lt;/goals&gt;
      &lt;/execution&gt;
   &lt;/executions&gt;
&lt;/plugin&gt;</pre>


<p class="wikiPara">
The metamodel source files get generated into the <tt>target/generated-sources/annotations</tt> directory.
</p>

<p class="wikiPara">
Note that if you have references to the metamodel across Java packages, you'll need to filter the annotation processor to only run on the package containing the entity classes.
</p>

<p class="wikiPara">
We'll be protoyping this approach in the 1.0.1.Beta1 release of the Weld archetypes, which should be out soon.
</p>

<h2 class="wikiHeadline2" id="H-BonusMaterialEclipseConfiguration"><a href="/Bloggers/AMoreConciseWayToGenerateTheJPA2MetamodelInMaven#H-BonusMaterialEclipseConfiguration">Bonus material: Eclipse configuration</a></h2>

<p class="wikiPara">
While I'm at it, I might as well show you how I enabled the JPA 2 metamodel generation in Eclipse. (Max may correct me. He's the authority on Eclipse tooling, so listen to what he says).
</p>

<p class="wikiPara">
Start by adding the following dependency to your POM:
</p>

<pre class="wikiPreformatted">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt;
   &lt;version&gt;1.0.0.Final&lt;/version&gt;
   &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre>


<p class="wikiPara">
Then, populate the .factorypath file at the root of your project with the following contents:
</p>

<pre class="wikiPreformatted">&lt;factorypath&gt;
    &lt;factorypathentry kind="PLUGIN" id="org.eclipse.jst.ws.annotations.core" enabled="true" runInBatchMode="false"/&gt;
    &lt;factorypathentry kind="VARJAR" id="M2_REPO/org/hibernate/hibernate-jpamodelgen/1.0.0.Final/hibernate-jpamodelgen-1.0.0.Final.jar" enabled="true" runInBatchMode="false"/&gt;
    &lt;factorypathentry kind="VARJAR" id="M2_REPO/org/hibernate/javax/persistence/hibernate-jpa-2.0-api/1.0.0.Final/hibernate-jpa-2.0-api-1.0.0.Final.jar" enabled="true" runInBatchMode="false"/&gt;
&lt;/factorypath&gt;</pre>


<p class="wikiPara">
Refresh the project in Eclipse. Now right click on the project and select:
</p>

<pre class="wikiPreformatted">Properties &gt; Java Compiler &gt; Annotation Processing</pre>


<p class="wikiPara">
Enable project specific settings and enable annotation processing. Press OK and OK again when prompted to build the project. Now, Eclipse should also generate your JPA 2 metamodel.
</p>

<p class="wikiPara">
Happy type-safe criteria querying!</p>
</div>
